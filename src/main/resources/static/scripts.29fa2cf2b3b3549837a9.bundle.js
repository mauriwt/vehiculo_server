webpackJsonp([4,11],{3:function(e,n,o){e.exports=o("vU3g")},"P+fo":function(e,n){e.exports=function(e){"undefined"!=typeof execScript?execScript(e):eval.call(null,e)}},n0Zf:function(e,n){e.exports="/**\n * @fileOverview Renders KML on the Google Maps JavaScript API Version 3\n * @name GeoXML3\n * @author Sterling Udell, Larry Ross, Brendan Byrd\n * @see http://code.google.com/p/geoxml3/\n *\n * geoxml3.js\n *\n * Renders KML on the Google Maps JavaScript API Version 3\n * http://code.google.com/p/geoxml3/\n *\n * Copyright 2010 Sterling Udell, Larry Ross\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n/**\n * A MultiGeometry object that will allow multiple polylines in a MultiGeometry\n * containing LineStrings to be treated as a single object\n *\n * @param {MutiGeometryOptions} anonymous object.  Available properties:\n * map: The map on which to attach the MultiGeometry\n * paths: the individual polylines\n * polylineOptions: options to use when constructing all the polylines\n *\n * @constructor\n */\n// only if Google Maps API included\nif (!!window.google && !! google.maps) { \nfunction MultiGeometry(multiGeometryOptions) {\n   function createPolyline(polylineOptions, mg) {\n     var polyline = new google.maps.Polyline(polylineOptions);\n     google.maps.event.addListener(polyline,'click', function(evt) { google.maps.event.trigger(mg,'click',evt);});\n     google.maps.event.addListener(polyline,'dblclick', function(evt) { google.maps.event.trigger(mg, 'dblclick', evt);});\n     google.maps.event.addListener(polyline,'mousedown', function(evt) { google.maps.event.trigger(mg, 'mousedown', evt);});\n     google.maps.event.addListener(polyline,'mousemove', function(evt) { google.maps.event.trigger(mg, 'mousemove', evt);});\n     google.maps.event.addListener(polyline,'mouseout', function(evt) { google.maps.event.trigger(mg, 'mouseout', evt);});\n     google.maps.event.addListener(polyline,'mouseover', function(evt) { google.maps.event.trigger(mg, 'mouseover', evt);});\n     google.maps.event.addListener(polyline,'mouseup', function(evt) { google.maps.event.trigger(mg, 'mouseup', evt);});\n     google.maps.event.addListener(polyline,'rightclick', function(evt) { google.maps.event.trigger(mg, 'rightclick', evt);});\n     return polyline;\n   }\n   this.setValues(multiGeometryOptions);\n   this.polylines = [];\n\n   for (i=0; i<this.paths.length;i++) {\n     var polylineOptions = multiGeometryOptions;\n     polylineOptions.path = this.paths[i];\n     var polyline = createPolyline(polylineOptions,this);\n     // Bind the polyline properties to the MultiGeometry properties\n     this.polylines.push(polyline);\n   }\n}\nMultiGeometry.prototype = new google.maps.MVCObject();\nMultiGeometry.prototype.changed = function(key) {\n    // alert(key+\" changed\");\n    if (this.polylines) {\n\tfor (var i=0; i<this.polylines.length; i++) {\n\t    this.polylines[i].set(key,this.get(key));\n\t}\n    }\n};\nMultiGeometry.prototype.setMap = function(map) { this.set('map',map); };\nMultiGeometry.prototype.getMap = function() { return this.get('map'); };\n}\n\n// Extend the global String object with a method to remove leading and trailing whitespace\nif (!String.prototype.trim) {\n/**\n * Remove leading and trailing whitespace.\n *\n * @augments String\n * @return {String}\n */\n  String.prototype.trim = function () {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n}\n\n/**\n * @namespace The GeoXML3 namespace.\n */\ngeoXML3 = window.geoXML3 || {instances: []};\n\n/**\n * Constructor for the root KML parser object.\n *\n * <p>All top-level objects and functions are declared under a namespace of geoXML3.\n * The core object is geoXML3.parser; typically, you'll instantiate a one parser\n * per map.</p>\n *\n * @class Main XML parser.\n * @param {geoXML3.parserOptions} options\n */\ngeoXML3.parser = function (options) {\n  // Inherit from Google MVC Object to include event handling   \n  google.maps.MVCObject.call(this);   \n\n  // Private variables\n  var parserOptions = new geoXML3.parserOptions(options);\n  var docs        = [];  // Individual KML documents\n  var docsByUrl   = {};  // Same docs as an hash by cleanURL\n  var kmzMetaData = {};  // Extra files from KMZ data\n  var styles      = {};  // Global list of styles\n  var lastPlacemark;\n  var parserName;\n  if (!parserOptions.infoWindow && parserOptions.singleInfoWindow)\n    parserOptions.infoWindow = new google.maps.InfoWindow();\n\n  var parseKmlString = function (kmlString, docSet) {\n    // Internal values for the set of documents as a whole\n    var internals = {\n      parser: this,\n      docSet: docSet || [],\n      remaining: 1,\n      parseOnly: !(parserOptions.afterParse || parserOptions.processStyles)\n    };\n    thisDoc = new Object();\n    thisDoc.internals = internals;\n    internals.docSet.push(thisDoc);\n    render(geoXML3.xmlParse(kmlString),thisDoc);\n  }\n\n  var parse = function (urls, docSet) {\n    // Process one or more KML documents\n    if (!parserName) {\n      parserName = 'geoXML3.instances[' + (geoXML3.instances.push(this) - 1) + ']';\n    }\n\n    if (typeof urls === 'string') {\n      // Single KML document\n      urls = [urls];\n    }\n\n    // Internal values for the set of documents as a whole\n    var internals = {\n      parser: this,\n      docSet: docSet || [],\n      remaining: urls.length,\n      parseOnly: !(parserOptions.afterParse || parserOptions.processStyles)\n    };\n    var thisDoc, j;\n    for (var i = 0; i < urls.length; i++) {\n      var baseUrl = cleanURL(defileURL(location.pathname), urls[i]);\n      if (docsByUrl[baseUrl]) {\n        // Reloading an existing document\n        thisDoc = docsByUrl[baseUrl];\n        thisDoc.reload = true;\n      }\n      else {\n        thisDoc = new Object();\n        thisDoc.baseUrl = baseUrl;\n        internals.docSet.push(thisDoc);\n      }\n      thisDoc.url       = urls[i];\n      thisDoc.internals = internals;\n      fetchDoc(thisDoc.url, thisDoc);\n    }\n  };\n\n  function fetchDoc(url, doc, resFunc) {\n    resFunc = resFunc || function (responseXML) { render(responseXML, doc); };\n\n    if (typeof ZipFile === 'function' && typeof JSIO === 'object' && typeof JSIO.guessFileType === 'function') {  // KMZ support requires these modules loaded\n      // if url is a data URI scheme, do not guess type based on extension.\n      if (/^data:[^,]*(kmz)/.test(doc.baseUrl)) {\n         contentType = JSIO.FileType.Binary;\n      } else if (/^data:[^,]*(kml|xml)/.test(doc.baseUrl)) {\n         contentType = JSIO.FileType.XML;\n      } else if (/^data:/.test(doc.baseUrl)) {\n         contentType = JSIO.FileType.Unknown;\n      } else if (parserOptions.forceZip) {\t\n         contentType = JSIO.FileType.Binary;\n      } else {\n         contentType = JSIO.guessFileType(doc.baseUrl);\n      }\n      if (contentType == JSIO.FileType.Binary || contentType == JSIO.FileType.Unknown) {\n         doc.isCompressed = true;\n         doc.baseDir = doc.baseUrl + '/';\n         geoXML3.fetchZIP(url, resFunc, doc.internals.parser);\n         return;\n      }\n    }\n    doc.isCompressed = false;\n    doc.baseDir = defileURL(doc.baseUrl);\n    geoXML3.fetchXML(url, resFunc);\n  }\n\n  var hideDocument = function (doc) {\n    if (!doc) doc = docs[0];\n    // Hide the map objects associated with a document\n    var i;\n    if (!!doc.markers) {\n      for (i = 0; i < doc.markers.length; i++) {\n        if(!!doc.markers[i].infoWindow) doc.markers[i].infoWindow.close();\n        doc.markers[i].setVisible(false);\n      }\n    }\n    if (!!doc.ggroundoverlays) {\n      for (i = 0; i < doc.ggroundoverlays.length; i++) {\n        doc.ggroundoverlays[i].setOpacity(0);\n      }\n    }\n    if (!!doc.gpolylines) {\n      for (i=0;i<doc.gpolylines.length;i++) {\n        if(!!doc.gpolylines[i].infoWindow) doc.gpolylines[i].infoWindow.close();\n        doc.gpolylines[i].setMap(null);\n      }\n    }\n    if (!!doc.gpolygons) {\n      for (i=0;i<doc.gpolygons.length;i++) {\n        if(!!doc.gpolygons[i].infoWindow) doc.gpolygons[i].infoWindow.close();\n        doc.gpolygons[i].setMap(null);\n      }\n    }\n  };\n\n  var showDocument = function (doc) {\n    if (!doc) doc = docs[0];\n    // Show the map objects associated with a document\n    var i;\n    if (!!doc.markers) {\n      for (i = 0; i < doc.markers.length; i++) {\n        doc.markers[i].setVisible(true);\n      }\n    }\n    if (!!doc.ggroundoverlays) {\n      for (i = 0; i < doc.ggroundoverlays.length; i++) {\n        doc.ggroundoverlays[i].setOpacity(doc.ggroundoverlays[i].percentOpacity_);\n      }\n    }\n    if (!!doc.gpolylines) {\n      for (i=0;i<doc.gpolylines.length;i++) {\n        doc.gpolylines[i].setMap(parserOptions.map);\n      }\n    }\n    if (!!doc.gpolygons) {\n      for (i=0;i<doc.gpolygons.length;i++) {\n        doc.gpolygons[i].setMap(parserOptions.map);\n      }\n    }\n  };\n\n  var defaultStyle = {\n    balloon: {\n      bgColor:   'ffffffff',\n      textColor: 'ff000000',\n      text: \"<h3>$[name]</h3>\\n<div>$[description]</div>\\n<div>$[geDirections]</div>\",\n      displayMode: 'default'\n    },\n    icon: {\n      scale: 1.0,\n      dim: {\n        x: 0,\n        y: 0,\n        w: -1,\n        h: -1\n      },\n      hotSpot: {\n        x: 0.5,\n        y: 0.5,\n        xunits: 'fraction',\n        yunits: 'fraction'\n      }\n    },\n    line: {\n      color: 'ffffffff', // white (KML default)\n      colorMode: 'normal',\n      width: 1.0\n    },\n    poly: {\n      color: 'ffffffff', // white (KML default)\n      colorMode: 'normal',\n      fill: true,\n      outline: true\n    }\n  };\n\n  var kmlNS = 'http://www.opengis.net/kml/2.2';\n  var gxNS  = 'http://www.google.com/kml/ext/2.2';\n  var nodeValue              = geoXML3.nodeValue;\n  var getBooleanValue        = geoXML3.getBooleanValue;\n  var getElementsByTagNameNS = geoXML3.getElementsByTagNameNS;\n  var getElementsByTagName   = geoXML3.getElementsByTagName;\n\nfunction processStyleUrl(node) {\n  var styleUrlStr = nodeValue(getElementsByTagName(node, 'styleUrl')[0]);\n  if (!!styleUrlStr && styleUrlStr.indexOf('#') != -1) \n    var styleUrl = styleUrlStr.split('#');\n  else var styleUrl = [\"\",\"\"];\n  return styleUrl;\n}\n\n  function processStyle(thisNode, baseUrl, styleID, baseDir) {\n    var style = (baseUrl === '{inline}') ? clone(defaultStyle) : (styles[baseUrl][styleID] = styles[baseUrl][styleID] || clone(defaultStyle));\n\n    var styleNodes = getElementsByTagName(thisNode, 'BalloonStyle');\n    if (!!styleNodes && styleNodes.length > 0) {\n      style.balloon.bgColor     = nodeValue(getElementsByTagName(styleNodes[0], 'bgColor')[0],     style.balloon.bgColor);\n      style.balloon.textColor   = nodeValue(getElementsByTagName(styleNodes[0], 'textColor')[0],   style.balloon.textColor);\n      style.balloon.text        = nodeValue(getElementsByTagName(styleNodes[0], 'text')[0],        style.balloon.text);\n      style.balloon.displayMode = nodeValue(getElementsByTagName(styleNodes[0], 'displayMode')[0], style.balloon.displayMode);\n    }\n\n    // style.list = (unsupported; doesn't make sense in Google Maps)\n\n    var styleNodes = getElementsByTagName(thisNode, 'IconStyle');\n    if (!!styleNodes && styleNodes.length > 0) {\n      var icon = style.icon;\n\n      icon.scale = parseFloat(nodeValue(getElementsByTagName(styleNodes[0], 'scale')[0], icon.scale));\n      // style.icon.heading   = (unsupported; not supported in API)\n      // style.icon.color     = (unsupported; not supported in API)\n      // style.icon.colorMode = (unsupported; not supported in API)\n\n      styleNodes = getElementsByTagName(styleNodes[0], 'hotSpot');\n      if (!!styleNodes && styleNodes.length > 0) {\n        icon.hotSpot = {\n          x:      styleNodes[0].getAttribute('x'),\n          y:      styleNodes[0].getAttribute('y'),\n          xunits: styleNodes[0].getAttribute('xunits'),\n          yunits: styleNodes[0].getAttribute('yunits')\n        };\n      }\n\n      styleNodes = getElementsByTagName(thisNode, 'Icon');\n      if (!!styleNodes && styleNodes.length > 0) {\n        icon.href = nodeValue(getElementsByTagName(styleNodes[0], 'href')[0]);\n        icon.url  = cleanURL(baseDir, icon.href);\n        // Detect images buried in KMZ files (and use a base64 encoded URL)\n        if (kmzMetaData[icon.url]) icon.url = kmzMetaData[icon.url].dataUrl;\n\n        // Support for icon palettes and exact size dimensions\n        icon.dim = {\n          x: parseInt(nodeValue(getElementsByTagNameNS(styleNodes[0], gxNS, 'x')[0], icon.dim.x)),\n          y: parseInt(nodeValue(getElementsByTagNameNS(styleNodes[0], gxNS, 'y')[0], icon.dim.y)),\n          w: parseInt(nodeValue(getElementsByTagNameNS(styleNodes[0], gxNS, 'w')[0], icon.dim.w)),\n          h: parseInt(nodeValue(getElementsByTagNameNS(styleNodes[0], gxNS, 'h')[0], icon.dim.h))\n        };\n\n        // certain occasions where we need the pixel size of the image (like the default settings...)\n        // (NOTE: Scale is applied to entire image, not just the section of the icon palette.  So,\n        //  if we need scaling, we'll need the img dimensions no matter what.)\n        if (true /* (icon.dim.w < 0 || icon.dim.h < 0) && (icon.xunits != 'pixels' || icon.yunits == 'fraction') || icon.scale != 1.0 */) {\n          // (hopefully, this will load by the time we need it...)\n          icon.img = new Image();\n          icon.img.onload = function() {\n            if (icon.dim.w < 0 || icon.dim.h < 0) {\n              icon.dim.w = this.width;\n              icon.dim.h = this.height;\n            } else {\n              icon.dim.th = this.height;\n            }\n          };\n          icon.img.src = icon.url;\n\n          // sometimes the file is already cached and it never calls onLoad\n          if (icon.img.width > 0) {\n            if (icon.dim.w < 0 || icon.dim.h < 0) {\n             icon.dim.w = icon.img.width;\n             icon.dim.h = icon.img.height;\n            } else {\n             icon.dim.th = icon.img.height;\n            }\n          }\n        }\n      }\n    }\n\n    // style.label = (unsupported; may be possible but not with API)\n\n    styleNodes = getElementsByTagName(thisNode, 'LineStyle');\n    if (!!styleNodes && styleNodes.length > 0) {\n      style.line.color     = nodeValue(getElementsByTagName(styleNodes[0], 'color')[0],     style.line.color);\n      style.line.colorMode = nodeValue(getElementsByTagName(styleNodes[0], 'colorMode')[0], style.line.colorMode);\n      style.line.width     = nodeValue(getElementsByTagName(styleNodes[0], 'width')[0],     style.line.width);\n      // style.line.outerColor      = (unsupported; not supported in API)\n      // style.line.outerWidth      = (unsupported; not supported in API)\n      // style.line.physicalWidth   = (unsupported; unneccesary in Google Maps)\n      // style.line.labelVisibility = (unsupported; possible to implement)\n    }\n\n    styleNodes = getElementsByTagName(thisNode, 'PolyStyle');\n    if (!!styleNodes && styleNodes.length > 0) {\n      style.poly.color     = nodeValue(      getElementsByTagName(styleNodes[0], 'color')[0],     style.poly.color);\n      style.poly.colorMode = nodeValue(      getElementsByTagName(styleNodes[0], 'colorMode')[0], style.poly.colorMode);\n      style.poly.outline   = getBooleanValue(getElementsByTagName(styleNodes[0], 'outline')[0],   style.poly.outline);\n      style.poly.fill      = getBooleanValue(getElementsByTagName(styleNodes[0], 'fill')[0],      style.poly.fill);\n    }\n    return style;\n  }\n\n  // from http://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-clone-a-javascript-object\n  // http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\n  function clone(obj){\n    if(obj == null || typeof(obj) != 'object') return obj;\n    if (obj.cloneNode) return obj.cloneNode(true);\n    var temp = new obj.constructor();\n    for(var key in obj) temp[key] = clone(obj[key]);\n    return temp;\n  }\n\n  function processStyleMap(thisNode, baseUrl, styleID, baseDir) {\n    var pairs = getElementsByTagName(thisNode, 'Pair');\n    var map = new Object();\n\n    // add each key to the map\n    for (var pr=0;pr<pairs.length;pr++) {\n      var pairKey      = nodeValue(getElementsByTagName(pairs[pr], 'key')[0]);\n      var pairStyle    = nodeValue(getElementsByTagName(pairs[pr], 'Style')[0]);\n      var pairStyleUrl = processStyleUrl(pairs[pr]);\n      var pairStyleBaseUrl = pairStyleUrl[0] ? cleanURL(baseDir, pairStyleUrl[0]) : baseUrl;\n      var pairStyleID      = pairStyleUrl[1];\n\n      if (!!pairStyle) {\n        map[pairKey] = processStyle(pairStyle, pairStyleBaseUrl, pairStyleID);\n      } else if (!!pairStyleID && !!styles[pairStyleBaseUrl][pairStyleID]) {\n        map[pairKey] = clone(styles[pairStyleBaseUrl][pairStyleID]);\n      }\n    }\n    if (!!map[\"normal\"]) {\n      styles[baseUrl][styleID] = clone(map[\"normal\"]);\n    } else {\n      styles[baseUrl][styleID] = clone(defaultStyle);\n    }\n    if (!!map[\"highlight\"] && !!parserOptions.processStyles) {\n      processStyleID(map[\"highlight\"]);\n    }\n    styles[baseUrl][styleID].map = clone(map);\n  }\n\n  function processPlacemarkCoords(node, tag) {\n    var parent = getElementsByTagName(node, tag);\n    var coordListA = [];\n    for (var i=0; i<parent.length; i++) {\n      var coordNodes = getElementsByTagName(parent[i], 'coordinates');\n      if (!coordNodes) {\n        if (coordListA.length > 0) {\n          break;\n        } else {\n          return [{coordinates: []}];\n        }\n      }\n\n      for (var j=0; j<coordNodes.length;j++) {\n        var coords = nodeValue(coordNodes[j]).trim();\n        coords = coords.replace(/,\\s+/g, ',');\n        var path = coords.split(/\\s+/g);\n        var pathLength = path.length;\n        var coordList = [];\n        for (var k = 0; k < pathLength; k++) {\n          coords = path[k].split(',');\n          if (!isNaN(coords[0]) && !isNaN(coords[1])) {\n            coordList.push({\n              lat: parseFloat(coords[1]),\n              lng: parseFloat(coords[0]),\n              alt: parseFloat(coords[2])\n            });\n          }\n        }\n        coordListA.push({coordinates: coordList});\n      }\n    }\n    return coordListA;\n  }\n\n  var render = function (responseXML, doc) {\n    // Callback for retrieving a KML document: parse the KML and display it on the map\n    if (!responseXML || responseXML == \"failed parse\") {\n      // Error retrieving the data\n      geoXML3.log('Unable to retrieve ' + doc.url);\n      if (parserOptions.failedParse) parserOptions.failedParse(doc);\n      doc.failed = true;\n      return;\n    } else if (responseXML.parseError && responseXML.parseError.errorCode != 0) {\n      // IE parse error\n      var err = responseXML.parseError;\n      var msg = 'Parse error in line ' + err.line + ', col ' + err.linePos + ' (error code: ' + err.errorCode + \")\\n\" +\n        \"\\nError Reason: \" + err.reason +\n        'Error Line: ' + err.srcText;\n\n      geoXML3.log('Unable to retrieve ' + doc.url + ': ' + msg);\n      if (parserOptions.failedParse) parserOptions.failedParse(doc);\n      doc.failed = true;\n      return;\n    } else if (responseXML.documentElement && responseXML.documentElement.nodeName == 'parsererror') {\n      // Firefox parse error\n      geoXML3.log('Unable to retrieve ' + doc.url + ': ' + responseXML.documentElement.childNodes[0].nodeValue);\n      if (parserOptions.failedParse) parserOptions.failedParse(doc);\n      doc.failed = true;\n      return;\n    } else if (!doc) {\n      throw 'geoXML3 internal error: render called with null document';\n    } else { //no errors\n      var i;\n      doc.placemarks      = [];\n      doc.groundoverlays  = [];\n      doc.ggroundoverlays = [];\n      doc.networkLinks    = [];\n      doc.gpolygons       = [];\n      doc.gpolylines      = [];\n\n      // Check for dependent KML files\n      var nodes = getElementsByTagName(responseXML, 'styleUrl');\n      var docSet = doc.internals.docSet;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var url = nodeValue(nodes[i]).split('#')[0];\n        if (!url)                 continue;  // #id (inside doc)\n        var rUrl = cleanURL( doc.baseDir, url );\n        if (rUrl === doc.baseUrl) continue;  // self\n        if (docsByUrl[rUrl])      continue;  // already loaded\n\n        var thisDoc;\n        var j = docSet.indexOfObjWithItem('baseUrl', rUrl);\n        if (j != -1) {\n          // Already listed to be loaded, but probably in the wrong order.\n          // Load it right away to immediately resolve dependency.\n          thisDoc = docSet[j];\n          if (thisDoc.failed) continue;  // failed to load last time; don't retry it again\n        }\n        else {\n          // Not listed at all; add it in\n          thisDoc           = new Object();\n          thisDoc.url       = rUrl;  // url can't be trusted inside KMZ files, since it may .. outside of the archive\n          thisDoc.baseUrl   = rUrl;\n          thisDoc.internals = doc.internals;\n\n          doc.internals.docSet.push(thisDoc);\n          doc.internals.remaining++;\n        }\n\n        // render dependent KML first then re-run renderer\n        fetchDoc(rUrl, thisDoc, function (thisResXML) {\n          render(thisResXML, thisDoc);\n          render(responseXML, doc);\n        });\n\n        // to prevent cross-dependency issues, just load the one\n        // file first and re-check the rest later\n        return;\n      }\n\n      // Parse styles\n      doc.styles = styles[doc.baseUrl] = styles[doc.baseUrl] || {};\n      var styleID, styleNodes;\n      nodes = getElementsByTagName(responseXML, 'Style');\n      nodeCount = nodes.length;\n      for (i = 0; i < nodeCount; i++) {\n        thisNode = nodes[i];\n        var styleID = thisNode.getAttribute('id');\n        if (!!styleID) processStyle(thisNode, doc.baseUrl, styleID, doc.baseDir);\n      }\n      // Parse StyleMap nodes\n      nodes = getElementsByTagName(responseXML, 'StyleMap');\n      for (i = 0; i < nodes.length; i++) {\n        thisNode = nodes[i];\n        var styleID = thisNode.getAttribute('id');\n        if (!!styleID) processStyleMap(thisNode, doc.baseUrl, styleID, doc.baseDir);\n      }\n\n      if (!!parserOptions.processStyles || !parserOptions.createMarker) {\n        // Convert parsed styles into GMaps equivalents\n        processStyles(doc);\n      }\n\n      // Parse placemarks\n      if (!!doc.reload && !!doc.markers) {\n        for (i = 0; i < doc.markers.length; i++) {\n          doc.markers[i].active = false;\n        }\n      }\n      var placemark, node, coords, path, marker, poly;\n      var pathLength, marker, polygonNodes, coordList;\n      var placemarkNodes = getElementsByTagName(responseXML, 'Placemark');\n      for (pm = 0; pm < placemarkNodes.length; pm++) {\n        // Init the placemark object\n        node = placemarkNodes[pm];\n        var styleUrl = processStyleUrl(node);\n        placemark = {\n          name:         nodeValue(getElementsByTagName(node, 'name')[0]),\n          description:  nodeValue(getElementsByTagName(node, 'description')[0]),\n          styleUrl:     styleUrl.join('#'),\n          styleBaseUrl: styleUrl[0] ? cleanURL(doc.baseDir, styleUrl[0]) : doc.baseUrl,\n          styleID:      styleUrl[1],\n          visibility:        getBooleanValue(getElementsByTagName(node, 'visibility')[0], true),\n          balloonVisibility: getBooleanValue(getElementsByTagNameNS(node, gxNS, 'balloonVisibility')[0], !parserOptions.suppressInfoWindows),\n          id:           node.getAttribute('id')\n        };\n        placemark.style = (styles[placemark.styleBaseUrl] && styles[placemark.styleBaseUrl][placemark.styleID]) || clone(defaultStyle);\n        // inline style overrides shared style\n        var inlineStyles = getElementsByTagName(node, 'Style');\n        if (inlineStyles && (inlineStyles.length > 0)) {\n          var style = processStyle(node, '{inline}', '{inline}');\n          processStyleID(style);\n          if (style) placemark.style = style;\n        }\n\n        if (/^https?:\\/\\//.test(placemark.description)) {\n          placemark.description = ['<a href=\"', placemark.description, '\">', placemark.description, '</a>'].join('');\n        }\n\n        // record list of variables for substitution\n        placemark.vars = {\n          display: {\n            name:         'Name',\n            description:  'Description',\n            address:      'Street Address',\n            id:           'ID',\n            Snippet:      'Snippet',\n            geDirections: 'Directions'\n          },\n          val: {\n            name:        placemark.name || '',\n            description: placemark.description || '',\n            address:     nodeValue(getElementsByTagName(node, 'address')[0], ''),\n            id:          node.getAttribute('id') || '',\n            Snippet:     nodeValue(getElementsByTagName(node, 'Snippet')[0], '')\n          },\n          directions: [\n            'f=d',\n            'source=GeoXML3'\n          ]\n        };\n\n        // add extended data to variables\n        var extDataNodes = getElementsByTagName(node, 'ExtendedData');\n        if (!!extDataNodes && extDataNodes.length > 0) {\n          var dataNodes = getElementsByTagName(extDataNodes[0], 'Data');\n          for (var d = 0; d < dataNodes.length; d++) {\n            var dn    = dataNodes[d];\n            var name  = dn.getAttribute('name');\n            if (!name) continue;\n            var dName = nodeValue(getElementsByTagName(dn, 'displayName')[0], name);\n            var val   = nodeValue(getElementsByTagName(dn, 'value')[0]);\n\n            placemark.vars.val[name]     = val;\n            placemark.vars.display[name] = dName;\n          }\n        }\n\n        // process MultiGeometry\n        var GeometryNodes = getElementsByTagName(node, 'coordinates');\n        var Geometry = null;\n        if (!!GeometryNodes && (GeometryNodes.length > 0)) {\n          for (var gn=0;gn<GeometryNodes.length;gn++) {\n            if (GeometryNodes[gn].parentNode &&\n                GeometryNodes[gn].parentNode.nodeName) {\n              var GeometryPN = GeometryNodes[gn].parentNode;\n              Geometry = GeometryPN.nodeName;\n\n              // Extract the coordinates\n              // What sort of placemark?\n              switch(Geometry) {\n                case \"Point\":\n                  placemark.Point = processPlacemarkCoords(node, \"Point\")[0];\n                  placemark.latlng = new google.maps.LatLng(placemark.Point.coordinates[0].lat, placemark.Point.coordinates[0].lng);\n                  pathLength = 1;\n                  break;\n                case \"LinearRing\":\n                  // Polygon/line\n                  polygonNodes = getElementsByTagName(node, 'Polygon');\n                  // Polygon\n                  if (!placemark.Polygon)\n                    placemark.Polygon = [{\n                      outerBoundaryIs: {coordinates: []},\n                      innerBoundaryIs: [{coordinates: []}]\n                    }];\n                  for (var pg=0;pg<polygonNodes.length;pg++) {\n                     placemark.Polygon[pg] = {\n                       outerBoundaryIs: {coordinates: []},\n                       innerBoundaryIs: [{coordinates: []}]\n                     }\n                     placemark.Polygon[pg].outerBoundaryIs = processPlacemarkCoords(polygonNodes[pg], \"outerBoundaryIs\");\n                     placemark.Polygon[pg].innerBoundaryIs = processPlacemarkCoords(polygonNodes[pg], \"innerBoundaryIs\");\n                  }\n                  coordList = placemark.Polygon[0].outerBoundaryIs;\n                  break;\n\n                case \"LineString\":\n                  pathLength = 0;\n                  placemark.LineString = processPlacemarkCoords(node,\"LineString\");\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          }\n        }\n\n\t// parse MultiTrack/Track\n        var TrackNodes = getElementsByTagNameNS(node,gxNS,\"Track\");\n        var coordListA = [];\n        if (TrackNodes.length > 0) {  \n          for (var i=0; i<TrackNodes.length; i++) {\n            var coordNodes = getElementsByTagNameNS(TrackNodes[i],gxNS,\"coord\");\n            var coordList = [];\n            for (var j=0; j<coordNodes.length;j++) { \n              var coords = geoXML3.nodeValue(coordNodes[j]).trim();\n              coords = coords.split(/\\s+/g);\n              if (!isNaN(coords[0]) && !isNaN(coords[1])) {\n                coordList.push({\n                  lat: parseFloat(coords[1]), \n                  lng: parseFloat(coords[0]), \n                  alt: parseFloat(coords[2])\n                });\n              }\n            }\n\t    coordListA.push({coordinates:coordList});\n          }\n          placemark.Track = coordListA;\n        }\n\t      \n        // call the custom placemark parse function if it is defined\n        if (!!parserOptions.pmParseFn) parserOptions.pmParseFn(node, placemark);\n        doc.placemarks.push(placemark);\n\n        // single marker\n        if (placemark.Point) {\n          if (!!google.maps) {\n            doc.bounds = doc.bounds || new google.maps.LatLngBounds();\n            doc.bounds.extend(placemark.latlng);\n          }\n\n          // Potential user-defined marker handler\n          var pointCreateFunc = parserOptions.createMarker || createMarker;\n          var found = false;\n          if (!parserOptions.createMarker) {\n            // Check to see if this marker was created on a previous load of this document\n            if (!!doc) {\n              doc.markers = doc.markers || [];\n              if (doc.reload) {\n                for (var j = 0; j < doc.markers.length; j++) {\n                    if ((doc.markers[j].id == placemark.id) ||\n\t\t\t// if no id, check position\n                        (!doc.markers[j].id && \n                         (doc.markers[j].getPosition().equals(placemark.latlng)))) {\n                    found = doc.markers[j].active = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          if (!found) {\n            // Call the marker creator\n            var marker = pointCreateFunc(placemark, doc);\n            if (marker) { \n              marker.active = placemark.visibility;\n              marker.id = placemark.id;\n            }\n          }\n        }\n        // polygon/line\n        var poly, line;\n        if (!!doc) {\n          if (placemark.Polygon)    doc.gpolygons  = doc.gpolygons  || [];\n          if (placemark.LineString) doc.gpolylines = doc.gpolylines || [];\n          if (placemark.Track)      doc.gpolylines = doc.gpolylines || [];\n        }\n\n        var polyCreateFunc = parserOptions.createPolygon    || createPolygon;\n        var lineCreateFunc = parserOptions.createLineString || createPolyline;\n        if (placemark.Polygon) {\n          poly = polyCreateFunc(placemark,doc);\n          if (poly) poly.active = placemark.visibility;\n        }\n        if (placemark.LineString) {\n          line = lineCreateFunc(placemark,doc);\n          if (line) line.active = placemark.visibility;\n        }\n\tif (placemark.Track) { // gx:Track polyline\n          line = lineCreateFunc(placemark,doc);\n          if (line) line.active = placemark.visibility;\n        }\n        if (!!google.maps) {\n          doc.bounds = doc.bounds || new google.maps.LatLngBounds();\n          if (poly) doc.bounds.union(poly.bounds);\n          if (line) doc.bounds.union(line.bounds);\n        }\n\n      } // placemark loop\n\n      if (!!doc.reload && !!doc.markers) {\n        for (i = doc.markers.length - 1; i >= 0 ; i--) {\n          if (!doc.markers[i].active) {\n            if (!!doc.markers[i].infoWindow) {\n              doc.markers[i].infoWindow.close();\n            }\n            doc.markers[i].setMap(null);\n            doc.markers.splice(i, 1);\n          }\n        }\n      }\n\n      var overlayCreateFunc = parserOptions.createOverlay || createOverlay;\n      // Parse ground overlays\n      if (!!doc.reload && !!doc.groundoverlays) {\n        for (i = 0; i < doc.groundoverlays.length; i++) {\n          doc.groundoverlays[i].active = false;\n        }\n      }\n\n      if (!!doc) {\n        doc.groundoverlays = doc.groundoverlays || [];\n      }\n      // doc.groundoverlays =[];\n      var groundOverlay, color, transparency, overlay;\n      var groundNodes = getElementsByTagName(responseXML, 'GroundOverlay');\n      for (i = 0; i < groundNodes.length; i++) {\n        node = groundNodes[i];\n\n        // Detect images buried in KMZ files (and use a base64 encoded URL)\n        var gnUrl = cleanURL( doc.baseDir, nodeValue(getElementsByTagName(node, 'href')[0]) );\n        if (kmzMetaData[gnUrl]) gnUrl = kmzMetaData[gnUrl].dataUrl;\n\n        // Init the ground overlay object\n        groundOverlay = {\n          name:        nodeValue(getElementsByTagName(node, 'name')[0]),\n          description: nodeValue(getElementsByTagName(node, 'description')[0]),\n          icon: { href: gnUrl },\n          latLonBox: {\n            north: parseFloat(nodeValue(getElementsByTagName(node, 'north')[0])),\n            east:  parseFloat(nodeValue(getElementsByTagName(node, 'east')[0])),\n            south: parseFloat(nodeValue(getElementsByTagName(node, 'south')[0])),\n            west:  parseFloat(nodeValue(getElementsByTagName(node, 'west')[0]))\n          },\n          rotation: -1 * parseFloat(nodeValue(getElementsByTagName(node, 'rotation')[0]))\n        };\n        if (!!google.maps) {\n          doc.bounds = doc.bounds || new google.maps.LatLngBounds();\n          doc.bounds.union(new google.maps.LatLngBounds(\n            new google.maps.LatLng(groundOverlay.latLonBox.south, groundOverlay.latLonBox.west),\n            new google.maps.LatLng(groundOverlay.latLonBox.north, groundOverlay.latLonBox.east)\n          ));\n        }\n\n        // Opacity is encoded in the color node\n        var colorNode = getElementsByTagName(node, 'color');\n        if (colorNode && colorNode.length > 0) {\n          groundOverlay.opacity = geoXML3.getOpacity(nodeValue(colorNode[0]));\n        } else {\n          groundOverlay.opacity = 1.0;  // KML default\n        }\n\n        doc.groundoverlays.push(groundOverlay);\n        // Check to see if this overlay was created on a previous load of this document\n        var found = false;\n        if (!!doc) {\n          doc.groundoverlays = doc.groundoverlays || [];\n          if (doc.reload) {\n            overlayBounds = new google.maps.LatLngBounds(\n              new google.maps.LatLng(groundOverlay.latLonBox.south, groundOverlay.latLonBox.west),\n              new google.maps.LatLng(groundOverlay.latLonBox.north, groundOverlay.latLonBox.east)\n            );\n            var overlays = doc.groundoverlays;\n            for (i = overlays.length; i--;) {\n              if ((overlays[i].bounds().equals(overlayBounds)) &&\n                  (overlays.url_ === groundOverlay.icon.href)) {\n                found = overlays[i].active = true;\n                break;\n              }\n            }\n          }\n\n          if (!found) {\n            overlay = overlayCreateFunc(groundOverlay, doc);\n            overlay.active = true;\n          }\n        }\n        if (!!doc.reload && !!doc.groundoverlays && !!doc.groundoverlays.length) {\n          var overlays = doc.groundoverlays;\n          for (i = overlays.length; i--;) {\n            if (!overlays[i].active) {\n              overlays[i].remove();\n              overlays.splice(i, 1);\n            }\n          }\n          doc.groundoverlays = overlays;\n        }\n      }\n\n      // Parse network links\n      var networkLink;\n      var docPath = document.location.pathname.split('/');\n      docPath = docPath.splice(0, docPath.length - 1).join('/');\n      var linkNodes = getElementsByTagName(responseXML, 'NetworkLink');\n      for (i = 0; i < linkNodes.length; i++) {\n        node = linkNodes[i];\n\n        // Init the network link object\n        networkLink = {\n          name: nodeValue(getElementsByTagName(node, 'name')[0]),\n          link: {\n            href:        nodeValue(getElementsByTagName(node, 'href')[0]),\n            refreshMode: nodeValue(getElementsByTagName(node, 'refreshMode')[0])\n          }\n        };\n\n        // Establish the specific refresh mode\n        if (!networkLink.link.refreshMode) {\n          networkLink.link.refreshMode = 'onChange';\n        }\n        if (networkLink.link.refreshMode === 'onInterval') {\n          networkLink.link.refreshInterval = parseFloat(nodeValue(getElementsByTagName(node, 'refreshInterval')[0]));\n          if (isNaN(networkLink.link.refreshInterval)) {\n            networkLink.link.refreshInterval = 0;\n          }\n        } else if (networkLink.link.refreshMode === 'onChange') {\n          networkLink.link.viewRefreshMode = nodeValue(getElementsByTagName(node, 'viewRefreshMode')[0]);\n          if (!networkLink.link.viewRefreshMode) {\n            networkLink.link.viewRefreshMode = 'never';\n          }\n          if (networkLink.link.viewRefreshMode === 'onStop') {\n            networkLink.link.viewRefreshTime = nodeValue(getElementsByTagName(node, 'refreshMode')[0]);\n            networkLink.link.viewFormat =      nodeValue(getElementsByTagName(node, 'refreshMode')[0]);\n            if (!networkLink.link.viewFormat) {\n              networkLink.link.viewFormat = 'BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]';\n            }\n          }\n        }\n\n        if (!/^[\\/|http]/.test(networkLink.link.href)) {\n          // Fully-qualify the HREF\n          networkLink.link.href = docPath + '/' + networkLink.link.href;\n        }\n\n        // Apply the link\n        if ((networkLink.link.refreshMode === 'onInterval') &&\n            (networkLink.link.refreshInterval > 0)) {\n          // Reload at regular intervals\n          setInterval(parserName + '.parse(\"' + networkLink.link.href + '\")',\n                      1000 * networkLink.link.refreshInterval);\n        } else if (networkLink.link.refreshMode === 'onChange') {\n          if (networkLink.link.viewRefreshMode === 'never') {\n            // Load the link just once\n            doc.internals.parser.parse(networkLink.link.href, doc.internals.docSet);\n          } else if (networkLink.link.viewRefreshMode === 'onStop') {\n            // Reload when the map view changes\n\n          }\n        }\n      }\n    }\n\n    if (!!doc.bounds) {\n      doc.internals.bounds = doc.internals.bounds || new google.maps.LatLngBounds();\n      doc.internals.bounds.union(doc.bounds);\n    }\n    if (!!doc.markers || !!doc.groundoverlays || !!doc.gpolylines || !!doc.gpolygons) {\n      doc.internals.parseOnly = false;\n    }\n\n    if (!doc.internals.parseOnly) {\n      // geoXML3 is not being used only as a real-time parser, so keep the processed documents around\n      if (doc.baseUrl){ // handle case from parseKmlString (no doc.baseUrl)\n        if (!docsByUrl[doc.baseUrl]) {\n          docs.push(doc);\n          docsByUrl[doc.baseUrl] = doc;\n        } else {\n          // internal replacement, which keeps the same memory ref loc in docs and docsByUrl\n          for (var i in docsByUrl[doc.baseUrl]) {\n            docsByUrl[doc.baseUrl][i] = doc[i];\n          }\n        }\n      }\t  \n    }\n\n    doc.internals.remaining--;\n    if (doc.internals.remaining === 0) {\n      // We're done processing this set of KML documents\n      // Options that get invoked after parsing completes\n      if (parserOptions.zoom && !!doc.internals.bounds &&\n\t  !doc.internals.bounds.isEmpty() && !!parserOptions.map) {\n        parserOptions.map.fitBounds(doc.internals.bounds);\n      }\n      if (parserOptions.afterParse) {\n        parserOptions.afterParse(doc.internals.docSet);\n      }\n      google.maps.event.trigger(doc.internals.parser, 'parsed');   \n    }\n  };\n\n  var kmlColor = function (kmlIn, colorMode) {\n    var kmlColor = {};\n    kmlIn = kmlIn || 'ffffffff';  // white (KML 2.2 default)\n\n    var aa = kmlIn.substr(0,2);\n    var bb = kmlIn.substr(2,2);\n    var gg = kmlIn.substr(4,2);\n    var rr = kmlIn.substr(6,2);\n\n    kmlColor.opacity = parseInt(aa, 16) / 256;\n    kmlColor.color   = (colorMode === 'random') ? randomColor(rr, gg, bb) : '#' + rr + gg + bb;\n    return kmlColor;\n  };\n\n  // Implemented per KML 2.2 <ColorStyle> specs\n  var randomColor = function(rr, gg, bb) {\n    var col = { rr: rr, gg: gg, bb: bb };\n    for (var k in col) {\n      var v = col[k];\n      if (v == null) v = 'ff';\n\n      // RGB values are limiters for random numbers (ie: 7f would be a random value between 0 and 7f)\n      v = Math.round(Math.random() * parseInt(rr, 16)).toString(16);\n      if (v.length === 1) v = '0' + v;\n      col[k] = v;\n    }\n\n    return '#' + col.rr + col.gg + col.bb;\n  };\n\n  var processStyleID = function (style) {\n    var icon = style.icon;\n    if (!icon || !icon.href) return;\n\n    if (icon.img && !icon.img.complete && (icon.dim.w < 0) && (icon.dim.h < 0) ) {\n      // we're still waiting on the image loading (probably because we've been blocking since the declaration)\n      // so, let's queue this function on the onload stack\n      icon.markerBacklog = [];\n      icon.img.onload = function() {\n        if (icon.dim.w < 0 || icon.dim.h < 0) {\n          icon.dim.w = this.width;\n          icon.dim.h = this.height;\n        } else {\n          icon.dim.th = this.height;\n        }\n        processStyleID(style);\n\n        // we will undoubtedly get some createMarker queuing, so set this up in advance\n        for (var i = 0; i < icon.markerBacklog.length; i++) {\n          var p = icon.markerBacklog[i][0];\n          var d = icon.markerBacklog[i][1];\n          createMarker(p, d);\n          if (p.marker) p.marker.active = true;\n        }\n        delete icon.markerBacklog;\n      };\n      return;\n    }\n    else { //if (icon.dim.w < 0 || icon.dim.h < 0) {\n      if (icon.img && icon.img.complete) {\n        // sometimes the file is already cached and it never calls onLoad\n        if (icon.dim.w < 0 || icon.dim.h < 0) {\n        icon.dim.w = icon.img.width;\n        icon.dim.h = icon.img.height;\n        } else {\n          icon.dim.th = icon.img.height;\n        }\n      }\n      else {\n        // settle for a default of 32x32\n        icon.dim.whGuess = true;\n        icon.dim.w = 32;\n        icon.dim.h = 32;\n        icon.dim.th = 32;\n      }\n    }\n\n    // pre-scaled variables\n    var rnd = Math.round;\n    var y = icon.dim.y;\n    if (typeof icon.dim.th !== 'undefined' && icon.dim.th != icon.dim.h) { // palette - reverse kml y for maps\n      y = Math.abs(y - (icon.dim.th - icon.dim.h));\n    }\n\n    var scaled = {\n      x: icon.dim.x     * icon.scale,\n      y: y * icon.scale,\n      w: icon.dim.w     * icon.scale,\n      h: icon.dim.h     * icon.scale,\n      aX:icon.hotSpot.x * icon.scale,\n      aY:icon.hotSpot.y * icon.scale,\n      iW:(icon.img ? icon.img.width  : icon.dim.w) * icon.scale,\n      iH:(icon.img ? icon.img.height : icon.dim.h) * icon.scale\n    };\n\n    // Figure out the anchor spot\n    // Origins, anchor positions and coordinates of the marker increase in the X direction to the right and in\n    // the Y direction down.\n    var aX, aY;\n    switch (icon.hotSpot.xunits) {\n      case 'fraction':    aX = rnd(scaled.aX * icon.dim.w); break;\n      case 'insetPixels': aX = rnd(icon.dim.w * icon.scale - scaled.aX); break;\n      default:            aX = rnd(scaled.aX); break; // already pixels\n    }\n    switch(icon.hotSpot.yunits) {\n      case 'fraction':    aY = scaled.h - rnd(icon.dim.h * scaled.aY);   break;\n      case 'insetPixels': aY = rnd(scaled.aY); break; \n      default:            aY = rnd(icon.dim.h * icon.scale - scaled.aY); break;\n    }\n    var iconAnchor = new google.maps.Point(aX, aY);\n\n    // Sizes\n    // (NOTE: Scale is applied to entire image, not just the section of the icon palette.)\n    var iconSize   = icon.dim.whGuess  ? null : new google.maps.Size(rnd(scaled.w),  rnd(scaled.h));\n    var iconScale  = icon.scale == 1.0 ? null :\n                     icon.dim.whGuess  ?        new google.maps.Size(rnd(scaled.w),  rnd(scaled.h))\n                                              : new google.maps.Size(rnd(scaled.iW), rnd(scaled.iH));\n    var iconOrigin = new google.maps.Point(rnd(scaled.x), rnd(scaled.y));\n\n    // Detect images buried in KMZ files (and use a base64 encoded URL)\n    if (kmzMetaData[icon.url]) icon.url = kmzMetaData[icon.url].dataUrl;\n\n    // Init the style object with the KML icon\n    icon.marker = {\n      url: icon.url,        // url\n      size: iconSize,       // size\n      origin: iconOrigin,   // origin\n      anchor: iconAnchor,   // anchor\n      scaledSize: iconScale // scaledSize\n    };\n\n    // Look for a predictable shadow\n    var stdRegEx = /\\/(red|blue|green|yellow|lightblue|purple|pink|orange)(-dot)?\\.png/;\n    var shadowSize = new google.maps.Size(59, 32);\n    var shadowPoint = new google.maps.Point(16, 32);\n    if (stdRegEx.test(icon.href)) {\n      // A standard GMap-style marker icon\n\ticon.shadow = {\n\t  url: 'http://maps.google.com/mapfiles/ms/micons/msmarker.shadow.png', // url\n          size: shadowSize,    // size\n          origin: null,        // origin\n\t  anchor: shadowPoint, // anchor\n          scaledSize: shadowSize // scaledSize\n\t};\n    } else if (icon.href.indexOf('-pushpin.png') > -1) {\n      // Pushpin marker icon\n      icon.shadow = {\n\turl: 'http://maps.google.com/mapfiles/ms/micons/pushpin_shadow.png',  // url\n        size: shadowSize,    // size\n        origin: null,        // origin\n        anchor: shadowPoint, // anchor\n        scaledSize: shadowSize // scaledSize\n      };\n    } /* else {\n      // Other MyMaps KML standard icon\n      icon.shadow = new google.maps.MarkerImage(\n        icon.href.replace('.png', '.shadow.png'),                        // url\n        shadowSize,                                                      // size\n        null,                                                            // origin\n        anchorPoint,                                                     // anchor\n        shadowSize                                                       // scaledSize\n      );\n    } */\n  }\n\n  var processStyles = function (doc) {\n    for (var styleID in doc.styles) {\n      processStyleID(doc.styles[styleID]);\n    }\n  };\n\n  var createMarker = function (placemark, doc) {\n    // create a Marker to the map from a placemark KML object\n    var icon = placemark.style.icon;\n\n    if ( !icon.marker && icon.img ) {\n      // yay, single point of failure is holding up multiple markers...\n      icon.markerBacklog = icon.markerBacklog || [];\n      icon.markerBacklog.push([placemark, doc]);\n      return;\n    }\n\n    // Load basic marker properties\n    var markerOptions = geoXML3.combineOptions(parserOptions.markerOptions, {\n      map:      parserOptions.map,\n      position: new google.maps.LatLng(placemark.Point.coordinates[0].lat, placemark.Point.coordinates[0].lng),\n      title:    placemark.name,\n      zIndex:   Math.round(placemark.Point.coordinates[0].lat * -100000)<<5,\n      icon:     icon.marker,\n      shadow:   icon.shadow,\n      flat:     !icon.shadow,\n      visible:  placemark.visibility\n    });\n\n    // Create the marker on the map\n    var marker = new google.maps.Marker(markerOptions);\n    if (!!doc) doc.markers.push(marker);\n\n    // Set up and create the infowindow if it is not suppressed\n    createInfoWindow(placemark, doc, marker);\n    placemark.marker = marker;\n    return marker;\n  };\n\n  var createOverlay = function (groundOverlay, doc) {\n    // Add a ProjectedOverlay to the map from a groundOverlay KML object\n\n    if (!window.ProjectedOverlay) {\n      throw 'geoXML3 error: ProjectedOverlay not found while rendering GroundOverlay from KML';\n    }\n\n    var bounds = new google.maps.LatLngBounds(\n        new google.maps.LatLng(groundOverlay.latLonBox.south, groundOverlay.latLonBox.west),\n        new google.maps.LatLng(groundOverlay.latLonBox.north, groundOverlay.latLonBox.east)\n    );\n    var overlayOptions = geoXML3.combineOptions(parserOptions.overlayOptions, {\n      percentOpacity: groundOverlay.opacity*100,\n      rotation: groundOverlay.rotation\n    });\n    var overlay = new ProjectedOverlay(parserOptions.map, groundOverlay.icon.href, bounds, overlayOptions);\n\n    if (!!doc) {\n      doc.ggroundoverlays = doc.ggroundoverlays || [];\n      doc.ggroundoverlays.push(overlay);\n    }\n\n    return overlay;\n  };\n\n  // Create Polyline\n  var createPolyline = function(placemark, doc) {\n    var paths = [];\n    var bounds = new google.maps.LatLngBounds();\n    if (placemark.LineString) {\n      for (var j=0; j<placemark.LineString.length; j++) {\n        var path = [];\n        var coords = placemark.LineString[j].coordinates;\n        for (var i=0;i<coords.length;i++) {\n          var pt = new google.maps.LatLng(coords[i].lat, coords[i].lng);\n          path.push(pt);\n          bounds.extend(pt);\n        }\n        paths.push(path);\n      }\n    } else if (placemark.Track) {\n      for (var j=0; j<placemark.Track.length; j++) {\n        var path = [];\n        var coords = placemark.Track[j].coordinates;\n        for (var i=0;i<coords.length;i++) {\n          var pt = new google.maps.LatLng(coords[i].lat, coords[i].lng);\n          path.push(pt);\n          bounds.extend(pt);\n        }\n        paths.push(path);\n      }\n    }\n    // point to open the infowindow if triggered\n    var point = paths[0][Math.floor(path.length/2)];\n    // Load basic polyline properties\n    var kmlStrokeColor = kmlColor(placemark.style.line.color, placemark.style.line.colorMode);\n    var polyOptions = geoXML3.combineOptions(parserOptions.polylineOptions, {\n      map:           parserOptions.map,\n      path:          path,\n      strokeColor:   kmlStrokeColor.color,\n      strokeWeight:  placemark.style.line.width,\n      strokeOpacity: kmlStrokeColor.opacity,\n      title:         placemark.name,\n      visible:       placemark.visibility\n    });\n    if (paths.length > 1) {\n      polyOptions.paths = paths;\n      var p = new MultiGeometry(polyOptions);\n    } else {\n      polyOptions.path = paths[0];\n      var p = new google.maps.Polyline(polyOptions);\n    }\n    p.bounds = bounds;\n\n    // setup and create the infoWindow if it is not suppressed\n    createInfoWindow(placemark, doc, p);\n    if (!!doc) doc.gpolylines.push(p);\n    placemark.polyline = p;\n    return p;\n  }\n\n  // Create Polygon\n  var createPolygon = function(placemark, doc) {\n    var bounds = new google.maps.LatLngBounds();\n    var pathsLength = 0;\n    var paths = [];\n    for (var polygonPart=0;polygonPart<placemark.Polygon.length;polygonPart++) {\n      for (var j=0; j<placemark.Polygon[polygonPart].outerBoundaryIs.length; j++) {\n        var coords = placemark.Polygon[polygonPart].outerBoundaryIs[j].coordinates;\n        var path = [];\n        for (var i=0;i<coords.length;i++) {\n          var pt = new google.maps.LatLng(coords[i].lat, coords[i].lng);\n          path.push(pt);\n          bounds.extend(pt);\n        }\n        paths.push(path);\n        pathsLength += path.length;\n      }\n      for (var j=0; j<placemark.Polygon[polygonPart].innerBoundaryIs.length; j++) {\n        var coords = placemark.Polygon[polygonPart].innerBoundaryIs[j].coordinates;\n        var path = [];\n        for (var i=0;i<coords.length;i++) {\n          var pt = new google.maps.LatLng(coords[i].lat, coords[i].lng);\n          path.push(pt);\n          bounds.extend(pt);\n        }\n        paths.push(path);\n        pathsLength += path.length;\n      }\n    }\n\n    // Load basic polygon properties\n    var kmlStrokeColor = kmlColor(placemark.style.line.color, placemark.style.line.colorMode);\n    var kmlFillColor = kmlColor(placemark.style.poly.color, placemark.style.poly.colorMode);\n    if (!placemark.style.poly.fill) kmlFillColor.opacity = 0.0;\n    var strokeWeight = placemark.style.line.width;\n    if (!placemark.style.poly.outline) {\n      strokeWeight = 0;\n      kmlStrokeColor.opacity = 0.0;\n    }\n    var polyOptions = geoXML3.combineOptions(parserOptions.polygonOptions, {\n      map:           parserOptions.map,\n      paths:         paths,\n      title:         placemark.name,\n      strokeColor:   kmlStrokeColor.color,\n      strokeWeight:  strokeWeight,\n      strokeOpacity: kmlStrokeColor.opacity,\n      fillColor:     kmlFillColor.color,\n      fillOpacity:   kmlFillColor.opacity,\n      visible:       placemark.visibility\n    });\n    var p = new google.maps.Polygon(polyOptions);\n    p.bounds = bounds;\n\n    createInfoWindow(placemark, doc, p);\n    if (!!doc) doc.gpolygons.push(p);\n    placemark.polygon = p;\n    return p;\n  }\n\n  var createInfoWindow = function(placemark, doc, gObj) {\n    var bStyle = placemark.style.balloon;\n    var vars = placemark.vars;\n\n    if (!placemark.balloonVisibility || bStyle.displayMode === 'hide') return;\n\n    // define geDirections \n    if (placemark.latlng && \n        (!parserOptions.suppressDirections || !parserOptions.suppressDirections)) {\n      vars.directions.push('sll=' + placemark.latlng.toUrlValue());\n\n      var url = 'http://maps.google.com/maps?' + vars.directions.join('&');\n      var address = encodeURIComponent( vars.val.address || placemark.latlng.toUrlValue() ).replace(/\\%20/g, '+');\n\n      vars.val.geDirections = '<a href=\"' + url + '&daddr=' + address + '\" target=_blank>To Here</a> - <a href=\"' + url + '&saddr=' + address + '\" target=_blank>From Here</a>';\n    }\n    else vars.val.geDirections = '';\n\n    // add in the variables\n    var iwText = bStyle.text.replace(/\\$\\[(\\w+(\\/displayName)?)\\]/g, function(txt, n, dn) { return dn ? vars.display[n] : vars.val[n]; });\n    var classTxt = 'geoxml3_infowindow geoxml3_style_' + placemark.styleID;\n\n    // color styles\n    var styleArr = [];\n    if (bStyle.bgColor   != 'ffffffff') styleArr.push('background: ' + kmlColor(bStyle.bgColor  ).color + ';');\n    if (bStyle.textColor != 'ff000000') styleArr.push('color: '      + kmlColor(bStyle.textColor).color + ';');\n    var styleProp = styleArr.length ? ' style=\"' + styleArr.join(' ') + '\"' : '';\n\n    var infoWindowOptions = geoXML3.combineOptions(parserOptions.infoWindowOptions, {\n      content: '<div class=\"' + classTxt + '\"' + styleProp + '>' + iwText + '</div>',\n      pixelOffset: new google.maps.Size(0, 2)\n    });\n\n    gObj.infoWindow = parserOptions.infoWindow || new google.maps.InfoWindow(infoWindowOptions);\n    gObj.infoWindowOptions = infoWindowOptions;\n\n    // Info Window-opening event handler\n    google.maps.event.addListener(gObj, 'click', function(e) {\n      var iW = this.infoWindow;\n      iW.close();\n      iW.setOptions(this.infoWindowOptions);\n\n      if      (e && e.latLng) iW.setPosition(e.latLng);\n      else if (this.bounds)   iW.setPosition(this.bounds.getCenter());\n\n      iW.setContent(\"<div id='geoxml3_infowindow'>\"+iW.getContent()+\"</div>\");\n      google.maps.event.addListenerOnce(iW, \"domready\", function() {\n        var node = document.getElementById('geoxml3_infowindow');\n        var imgArray = node.getElementsByTagName('img');\n        for (var i = 0; i < imgArray.length; i++) \n        {\n          var imgUrlIE = imgArray[i].getAttribute(\"src\");\n          var imgUrl  = cleanURL(doc.baseDir, imgUrlIE);\n\n          if (kmzMetaData[imgUrl]) {\n             imgArray[i].src = kmzMetaData[imgUrl].dataUrl;\n          } else if (kmzMetaData[imgUrlIE]) {\n             imgArray[i].src = kmzMetaData[imgUrlIE].dataUrl;\n          }\n        }\n      });\n      iW.open(this.map, this.bounds ? null : this);\n    });\n\n  }\n\n  return {\n    // Expose some properties and methods\n\n    options:     parserOptions,\n    docs:        docs,\n    docsByUrl:   docsByUrl,\n    kmzMetaData: kmzMetaData,\n\n    parse:          parse,\n    render:         render,\n    parseKmlString: parseKmlString,\n    hideDocument:   hideDocument,\n    showDocument:   showDocument,\n    processStyles:  processStyles,\n    createMarker:   createMarker,\n    createOverlay:  createOverlay,\n    createPolyline: createPolyline,\n    createPolygon:  createPolygon\n  };\n};\n// End of KML Parser\n\n// Helper objects and functions\ngeoXML3.getOpacity = function (kmlColor) {\n  // Extract opacity encoded in a KML color value. Returns a number between 0 and 1.\n  if (!!kmlColor &&\n      (kmlColor !== '') &&\n      (kmlColor.length == 8)) {\n    var transparency = parseInt(kmlColor.substr(0, 2), 16);\n    return transparency / 255;\n  } else {\n    return 1;\n  }\n};\n\n// Log a message to the debugging console, if one exists\ngeoXML3.log = function(msg) {\n  if (!!window.console) {\n    console.log(msg);\n  } else { alert(\"log:\"+msg); }\n};\n\n/**\n * Creates a new parserOptions object.\n * @class GeoXML3 parser options.\n * @param {Object} overrides Any options you want to declare outside of the defaults should be included here.\n * @property {google.maps.Map} map The API map on which geo objects should be rendered.\n * @property {google.maps.MarkerOptions} markerOptions If the parser is adding Markers to the map itself, any options specified here will be applied to them.\n * @property {google.maps.InfoWindowOptions} infoWindowOptions If the parser is adding Markers to the map itself, any options specified here will be applied to their attached InfoWindows.\n * @property {ProjectedOverlay.options} overlayOptions If the parser is adding ProjectedOverlays to the map itself, any options specified here will be applied to them.\n */\ngeoXML3.parserOptions = function (overrides) {\n  this.map                 = null,\n  /** If true, the parser will automatically move the map to a best-fit of the geodata after parsing of a KML document completes.\n   * @type Boolean\n   * @default true\n   */\n  this.zoom                = true,\n  /**#@+ @type Boolean\n   *     @default false */\n  /** If true, only a single Marker created by the parser will be able to have its InfoWindow open at once (simulating the behavior of GMaps API v2). */\n  this.singleInfoWindow    = false,\n  /** If true, suppresses the rendering of info windows. */\n  this.suppressInfoWindows = false,\n  /**\n   * Control whether to process styles now or later.\n   *\n   * <p>By default, the parser only processes KML &lt;Style&gt; elements into their GMaps equivalents\n   * if it will be creating its own Markers (the createMarker option is null). Setting this option\n   * to true will force such processing to happen anyway, useful if you're going to be calling parser.createMarker\n   * yourself later. OTOH, leaving this option false removes runtime dependency on the GMaps API, enabling\n   * the use of geoXML3 as a standalone KML parser.</p>\n   */\n  this.processStyles       = false,\n  /**#@-*/\n\n  this.markerOptions       = {},\n  this.infoWindowOptions   = {},\n  this.overlayOptions      = {},\n\n  /**#@+ @event */\n  /** This function will be called when parsing of a KML document is complete.\n   * @param {geoXML3.parser#docs} doc Parsed KML data. */\n  this.afterParse          = null,\n  /** This function will be called when parsing of a KML document is complete.\n   * @param {geoXML3.parser#docs} doc Parsed KML data. */\n  this.failedParse         = null,\n  /**\n   * If supplied, this function will be called once for each marker <Placemark> in the KML document, instead of the parser adding its own Marker to the map.\n   * @param {geoXML3.parser.render#placemark} placemark Placemark object.\n   * @param {geoXML3.parser#docs} doc Parsed KML data.\n   */\n  this.createMarker        = null,\n  /**\n   * If supplied, this function will be called once for each <GroundOverlay> in the KML document, instead of the parser adding its own ProjectedOverlay to the map.\n   * @param {geoXML3.parser.render#groundOverlay} groundOverlay GroundOverlay object.\n   * @param {geoXML3.parser#docs} doc Parsed KML data.\n   */\n  this.createOverlay       = null\n  /**#@-*/\n\n  if (overrides) {\n    for (var prop in overrides) {\n      if (overrides.hasOwnProperty(prop)) this[prop] = overrides[prop];\n    }\n  }\n  return this;\n};\n\n/**\n * Combine two options objects: a set of default values and a set of override values.\n *\n * @deprecated This has been replaced with {@link geoXML3.parserOptions#combineOptions}.\n * @param {geoXML3.parserOptions|Object} overrides Override values.\n * @param {geoXML3.parserOptions|Object} defaults Default values.\n * @return {geoXML3.parserOptions} Combined result.\n */\ngeoXML3.combineOptions = function (overrides, defaults) {\n  var result = {};\n  if (!!overrides) {\n    for (var prop in overrides) {\n      if (overrides.hasOwnProperty(prop))                              result[prop] = overrides[prop];\n    }\n  }\n  if (!!defaults) {\n    for (prop in defaults) {\n      if (defaults.hasOwnProperty(prop) && result[prop] === undefined) result[prop] = defaults[prop];\n    }\n  }\n  return result;\n};\n\n/**\n * Combine two options objects: a set of default values and a set of override values.\n *\n * @function\n * @param {geoXML3.parserOptions|Object} overrides Override values.\n * @param {geoXML3.parserOptions|Object} defaults Default values.\n * @return {geoXML3.parserOptions} Combined result.\n */\ngeoXML3.parserOptions.prototype.combineOptions = geoXML3.combineOptions;\n\n// Retrieve an XML document from url and pass it to callback as a DOM document\ngeoXML3.fetchers = [];\n\n/**\n * Parses a XML string.\n *\n * <p>Parses the given XML string and returns the parsed document in a\n * DOM data structure. This function will return an empty DOM node if\n * XML parsing is not supported in this browser.</p>\n *\n * @param {String} str XML string.\n * @return {Element|Document} DOM.\n */\ngeoXML3.xmlParse = function (str) {\n  if ((typeof ActiveXObject != 'undefined') || (\"ActiveXObject\" in window)) {\n    var doc = new ActiveXObject('Microsoft.XMLDOM');\n    doc.loadXML(str);\n    return doc;\n  }\n\n  if (typeof DOMParser != 'undefined') {\n    return (new DOMParser()).parseFromString(str, 'text/xml');\n  }\n\n  return document.createElement('div', null);\n}\n\n/**\n * Checks for XML parse error.\n *\n * @param {xmlDOM} XML DOM.\n * @return boolean.\n */\n// from http://stackoverflow.com/questions/11563554/how-do-i-detect-xml-parsing-errors-when-using-javascripts-domparser-in-a-cross\ngeoXML3.isParseError = function(parsedDocument) {\n    if ((typeof ActiveXObject != 'undefined') || (\"ActiveXObject\" in window))\n\treturn false;\n    // parser and parsererrorNS could be cached on startup for efficiency\n    var p = new DOMParser(),\n        errorneousParse = p.parseFromString('<', 'text/xml'),\n        parsererrorNS = errorneousParse.getElementsByTagName(\"parsererror\")[0].namespaceURI;\n\n    if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {\n        // In PhantomJS the parseerror element doesn't seem to have a special namespace, so we are just guessing here :(\n        return parsedDocument.getElementsByTagName(\"parsererror\").length > 0;\n    }\n\n    return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;\n};\n\n/**\n * Fetches a XML document.\n *\n * <p>Fetches/parses the given XML URL and passes the parsed document (in a\n * DOM data structure) to the given callback.  Documents are downloaded\n * and parsed asynchronously.</p>\n *\n * @param {String} url URL of XML document.  Must be uncompressed XML only.\n * @param {Function(Document)} callback Function to call when the document is processed.\n */\ngeoXML3.fetchXML = function (url, callback) {\n  function timeoutHandler() { callback(); };\n\n  var xhrFetcher = new Object();\n  if      (!!geoXML3.fetchers.length) xhrFetcher = geoXML3.fetchers.pop();\n  else if (!!window.XMLHttpRequest)   xhrFetcher.fetcher = new window.XMLHttpRequest();  // Most browsers\n  else if (!!window.ActiveXObject) {                                                     // Some IE\n    // the many versions of IE's XML fetchers\n    var AXOs = [\n      'MSXML2.XMLHTTP.6.0',\n      'MSXML2.XMLHTTP.5.0',\n      'MSXML2.XMLHTTP.4.0',\n      'MSXML2.XMLHTTP.3.0',\n      'MSXML2.XMLHTTP',\n      'Microsoft.XMLHTTP',\n      'MSXML.XMLHTTP'\n    ];\n    for (var i = 0; i < AXOs.length; i++) {\n      try      { xhrFetcher.fetcher = new ActiveXObject(AXOs[i]); break; }\n      catch(e) { continue; }\n    }\n    if (!xhrFetcher.fetcher) {\n      geoXML3.log('Unable to create XHR object');\n      callback(null);\n      return null;\n    }\n  }\n\n  xhrFetcher.fetcher.open('GET', url, true);\n  if (!!xhrFetcher.fetcher.overrideMimeType) xhrFetcher.fetcher.overrideMimeType('text/xml');\n  xhrFetcher.fetcher.onreadystatechange = function () {\n    if (xhrFetcher.fetcher.readyState === 4) {\n      // Retrieval complete\n      if (!!xhrFetcher.xhrtimeout) clearTimeout(xhrFetcher.xhrtimeout);\n      if (xhrFetcher.fetcher.status >= 400) {\n        geoXML3.log('HTTP error ' + xhrFetcher.fetcher.status + ' retrieving ' + url);\n        callback();\n      }\n      // Returned successfully\n      else {\n       if (xhrFetcher.fetcher.responseXML) {\n        // Sometimes IE will get the data, but won't bother loading it as an XML doc\n        var xml = xhrFetcher.fetcher.responseXML;\n        if (xml && !xml.documentElement && !xml.ownerElement) {\n         xml.loadXML(xhrFetcher.fetcher.responseText);\n        }\n       } else {// handle valid xml sent with wrong MIME type \n        xml=geoXML3.xmlParse(xhrFetcher.fetcher.responseText);\n       }\n       // handle parse errors\n       if (xml.parseError && (xml.parseError.errorCode != 0)) {\n        geoXML3.log(\"XML parse error \"+xml.parseError.errorCode+\", \"+xml.parseError.reason+\"\\nLine:\"+xml.parseError.line+\", Position:\"+xml.parseError.linepos+\", srcText:\"+xml.parseError.srcText);\n        xml = \"failed parse\"\n       } else if (geoXML3.isParseError(xml)) {\n        geoXML3.log(\"XML parse error\");\n        xml = \"failed parse\"\n       }\n       callback(xml);          \n      }\n      // We're done with this fetcher object\n      geoXML3.fetchers.push(xhrFetcher);\n    }\n  };\n\n  xhrFetcher.xhrtimeout = setTimeout(timeoutHandler, 60000);\n  xhrFetcher.fetcher.send(null);\n  return null;\n};\n\nvar IEversion = function() {\n  // http://msdn.microsoft.com/workshop/author/dhtml/overview/browserdetection.asp\n  // Returns the version of Internet Explorer or a -1\n  // (indicating the use of another browser).\n  var rv = -1; // Return value assumes failure\n  if (navigator.appName == 'Microsoft Internet Explorer') {\n    var ua = navigator.userAgent;\n    var re = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n    if (re.exec(ua) != null) {\n      rv = parseFloat( RegExp.$1 );\n    }\n  }\n  return rv;\n};\n\n/**\n * Fetches a KMZ document.\n *\n * <p>Fetches/parses the given ZIP URL, parses each image file, and passes\n * the parsed KML document to the given callback.  Documents are downloaded\n * and parsed asynchronously, though the KML file is always passed after the\n * images have been processed, in case the callback requires the image data.</p>\n *\n * @requires ZipFile.complete.js\n * @param {String} url URL of KMZ document.  Must be a valid KMZ/ZIP archive.\n * @param {Function(Document)} callback Function to call when the document is processed.\n * @param {geoXML3.parser} parser A geoXML3.parser object.  This is used to populate the KMZ image data.\n * @author Brendan Byrd\n * @see http://code.google.com/apis/kml/documentation/kmzarchives.html\n */\ngeoXML3.fetchZIP = function (url, callback, parser) {\n  // Just need a single 'new' declaration with a really long function...\n  var zipFile = new ZipFile(url, function (zip) {\n    // Retrieval complete\n\n    // Check for ERRORs in zip.status\n    for (var i = 0; i < zip.status.length; i++) {\n      var msg = zip.status[i];\n      if (msg.indexOf(\"ERROR\") == 0) {\n        geoXML3.log('HTTP/ZIP error retrieving ' + url + ': ' + msg);\n        callback();\n        return;\n      }\n      else if (msg.indexOf(\"EXCEPTION\") == 0) {  \n        geoXML3.log('HTTP/ZIP exception retrieving ' + url + ': ' + msg);\n        callback();\n        return;\n      } else if (msg.indexOf(\"WARNING\") == 0) {  // non-fatal, but still might be useful\n        geoXML3.log('HTTP/ZIP warning retrieving ' + url + ': ' + msg);\n      } else if (msg.indexOf(\"INFO\") == 0) {  // non-fatal, but still might be useful\n        geoXML3.log('HTTP/ZIP info retrieving ' + url + ': ' + msg);\n      }\n    }\n\n    // Make sure KMZ structure is according to spec (with a single KML file in the root dir)\n    var KMLCount = 0;\n    var KML;\n    for (var i = 0; i < zip.entries.length; i++) {\n      var name = zip.entries[i].name;\n      if (!/\\.kml$/.test(name)) continue;\n\n      KMLCount++;\n      if (KMLCount == 1) KML = i;\n      else {\n        geoXML3.log('KMZ warning retrieving ' + url + ': found extra KML \"' + name + '\" in KMZ; discarding...');\n      }\n    }\n\n    // Returned successfully, but still needs extracting\n    var baseUrl = cleanURL(defileURL(url), url) + '/';\n    var kmlProcessing = {  // this is an object just so it gets passed properly\n      timer: null,\n      extractLeft: 0,\n      timerCalls: 0\n    };\n    var extractCb = function(entry, entryContent) {\n      var mdUrl = cleanURL(baseUrl, entry.name);\n      var ext = entry.name.substring(entry.name.lastIndexOf(\".\") + 1).toLowerCase();\n      kmlProcessing.extractLeft--;\n\n      if ((typeof entryContent.description == \"string\") && (entryContent.name == \"Error\")) {\n        geoXML3.log('KMZ error extracting ' + mdUrl + ': ' + entryContent.description);\n        callback();\n        return;\n      }\n\n      // MIME types that can be used in KML\n      var mime;\n      if (ext === 'jpg') ext = 'jpeg';\n      if (/^(gif|jpeg|png)$/.test(ext)) mime = 'image/' + ext;\n      else if (ext === 'mp3')           mime = 'audio/mpeg';\n      else if (ext === 'm4a')           mime = 'audio/mp4';\n      else if (ext === 'm4a')           mime = 'audio/MP4-LATM';\n      else                              mime = 'application/octet-stream';\n\n      parser.kmzMetaData[mdUrl] = {};\n      parser.kmzMetaData[mdUrl].entry = entry;\n      // data:image/gif;base64,R0lGODlhEAAOALMA...\n      parser.kmzMetaData[mdUrl].dataUrl = 'data:' + mime + ';base64,' + base64Encode(entryContent);\n      // IE cannot handle GET requests beyond 2071 characters, even if it's an inline image\n\tif (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent))\n        { \n            if (((IEversion() < 8.0) &&\n                 (parser.kmzMetaData[mdUrl].dataUrl.length > 2071)) ||\n                ((IEversion < 9.0) && \n                 (parser.kmzMetaData[mdUrl].dataUrl.length > 32767))) {\n             parser.kmzMetaData[mdUrl].dataUrl =\n             // this is a simple IE icon; to hint at the problem...\n             'data:image/gif;base64,R0lGODlhDwAQAOMPADBPvSpQ1Dpoyz1p6FhwvU2A6ECP63CM04CWxYCk+V6x+UK++Jao3rvC3fj7+v///yH5BAEKAA8ALAAAAAAPABAAAASC8Mk5mwCAUMlWwcLRHEelLA' +\n             'oGDMgzSsiyGCAhCETDPMh5XQCBwYBrNBIKWmg0MCQHj8MJU5IoroYCY6AAAgrDIbbQDGIK6DR5UPhlNo0JAlSUNAiDgH7eNAxEDWAKCQM2AAFheVxYAA0AIkFOJ1gBcQQaUQKKA5w7LpcEBwkJaKMUEQA7';\n            } \n       }\n       parser.kmzMetaData[internalSrc(entry.name)]=parser.kmzMetaData[mdUrl];\t\n\n    };\n    var kmlExtractCb = function(entry, entryContent) {\n      if ((typeof entryContent.description == \"string\") && (entryContent.name == \"Error\")) {\n        geoXML3.log('KMZ error extracting ' + entry.name + ': ' + entryContent.description);\n        callback();\n        return;\n      }\n\n      // check to see if the KML is the last file extracted\n      clearTimeout(kmlProcessing.timer);\n      if (kmlProcessing.extractLeft <= 1) {\n        kmlProcessing.extractLeft--;\n        callback(geoXML3.xmlParse(entryContent));\n        return;\n      }\n      else {\n        // KML file isn't last yet; it may need to use those files, so wait a bit (100ms)\n        kmlProcessing.timerCalls++;\n        if (kmlProcessing.timerCalls < 100) {\n          kmlProcessing.timer = setTimeout(function() { kmlExtractCb(entry, entryContent); }, 100);\n        }\n        else {\n          geoXML3.log('KMZ warning extracting ' + url + ': entire ZIP has not been extracted after 10 seconds; running through KML, anyway...');\n          kmlProcessing.extractLeft--;\n          callback(geoXML3.xmlParse(entryContent));\n        }\n      }\n      return;\n    };\n    for (var i = 0; i < zip.entries.length; i++) {\n      var entry = zip.entries[i];\n      var ext = entry.name.substring(entry.name.lastIndexOf(\".\") + 1).toLowerCase();\n      if (!/^(gif|jpe?g|png|kml)$/.test(ext)) continue;  // not going to bother to extract files we don't support\n      if (ext === \"kml\" && i != KML)          continue;  // extra KMLs get discarded\n      if (!parser && ext != \"kml\")            continue;  // cannot store images without a parser object\n\n      // extract asynchronously\n      kmlProcessing.extractLeft++;\n      if (ext === \"kml\") entry.extract(kmlExtractCb);\n      else               entry.extract(extractCb);\n    }\n  }); //,3 for most verbose logging\n\n};\n\n/**\n * Extract the text value of a DOM node, with leading and trailing whitespace trimmed.\n *\n * @param {Element} node XML node/element.\n * @param {Any} delVal Default value if the node doesn't exist.\n * @return {String|Null}\n */\ngeoXML3.nodeValue = function(node, defVal) {\n  var retStr=\"\";\n  if (!node) {\n    return (typeof defVal === 'undefined' || defVal === null) ? null : defVal;\n  }\n   if(node.nodeType==3||node.nodeType==4||node.nodeType==2){\n      retStr+=node.nodeValue;\n   }else if(node.nodeType==1||node.nodeType==9||node.nodeType==11){\n      for(var i=0;i<node.childNodes.length;++i){\n         retStr+=arguments.callee(node.childNodes[i]);\n      }\n   }\n   return retStr;\n};\n\n/**\n * Loosely translate various values of a DOM node to a boolean.\n *\n * @param {Element} node XML node/element.\n * @param {Boolean} delVal Default value if the node doesn't exist.\n * @return {Boolean|Null}\n */\ngeoXML3.getBooleanValue = function(node, defVal) {\n  var nodeContents = geoXML3.nodeValue(node);\n  if (nodeContents === null) return defVal || false;\n  nodeContents = parseInt(nodeContents);\n  if (isNaN(nodeContents)) return true;\n  if (nodeContents == 0) return false;\n  else return true;\n}\n\n/**\n * Browser-normalized version of getElementsByTagNameNS.\n *\n * <p>Required because IE8 doesn't define it.</p>\n *\n * @param {Element|Document} node DOM object.\n * @param {String} namespace Full namespace URL to search against.\n * @param {String} tagname XML local tag name.\n * @return {Array of Elements}\n * @author Brendan Byrd\n */\ngeoXML3.getElementsByTagNameNS = function(node, namespace, tagname) {\n  if (node && typeof node.getElementsByTagNameNS != 'undefined') return node.getElementsByTagNameNS(namespace, tagname);\n  if (!node) return [];\n\n  var root = node.documentElement || node.ownerDocument && node.ownerDocument.documentElement;\n  if (!root || !root.attributes) return [];\n\n  // search for namespace prefix\n  for (var i = 0; i < root.attributes.length; i++) {\n    var attr = root.attributes[i];\n    if      (attr.prefix   === 'xmlns' && attr.nodeValue === namespace) return node.getElementsByTagName(attr.baseName + ':' + tagname);\n    else if (attr.nodeName === 'xmlns' && attr.nodeValue === namespace) {\n      // default namespace\n      if (typeof node.selectNodes != 'undefined') {\n        // Newer IEs have the SelectionNamespace property that can be used with selectNodes\n        if (!root.ownerDocument.getProperty('SelectionNamespaces'))\n          root.ownerDocument.setProperty('SelectionNamespaces', \"xmlns:defaultNS='\" + namespace + \"'\");\n        return node.selectNodes('.//defaultNS:' + tagname);\n      }\n      else {\n        // Otherwise, you can still try to tack on the 'xmlns' attribute to root\n        root.setAttribute('xmlns:defaultNS', namespace);\n        return node.getElementsByTagName('defaultNS:' + tagname);\n      }\n    }\n  }\n  return geoXML3.getElementsByTagName(node, tagname);  // try the unqualified version\n};\n\n/**\n * Browser-normalized version of getElementsByTagName.\n *\n * <p>Required because MSXML 6.0 will treat this function as a NS-qualified function,\n * despite the missing NS parameter.</p>\n *\n * @param {Element|Document} node DOM object.\n * @param {String} tagname XML local tag name.\n * @return {Array of Elements}\n * @author Brendan Byrd\n */\ngeoXML3.getElementsByTagName = function(node, tagname) {\n  if (node && typeof node.getElementsByTagNameNS != 'undefined') return node.getElementsByTagName(tagname);  // if it has both functions, it should be accurate\n//  if (node && typeof node.selectNodes != 'undefined')            return node.selectNodes(\".//*[local-name()='\" + tagname + \"']\");\n  return node.getElementsByTagName(tagname);  // hope for the best...\n}\n\n/**\n * Turn a directory + relative URL into an absolute one.\n *\n * @private\n * @param {String} d Base directory.\n * @param {String} s Relative URL.\n * @return {String} Absolute URL.\n * @author Brendan Byrd\n */\nvar toAbsURL = function (d, s) {\n  var p, f, i;\n  var h = location.protocol + \"://\" + location.host;\n\n  if (!s.length)           return '';\n  if (/^\\w+:/.test(s))     return s;\n  if (s.indexOf('/') == 0) return h + s;\n\n  p = d.replace(/\\/[^\\/]*$/, '');\n  f = s.match(/\\.\\.\\//g);\n  if (f) {\n    s = s.substring(f.length * 3);\n    for (i = f.length; i--;) { p = p.substring(0, p.lastIndexOf('/')); }\n  }\n\n  return h + p + '/' + s;\n}\n\nvar internalSrc = function(src) {\n  //this gets the full url\n  var url = document.location.href;\n  //this removes everything after the last slash in the path\n  url = url.substring(0,url.lastIndexOf(\"/\") + 1);\n  var internalPath= url+src;\n  return internalPath;\n}\n\n/**\n * Remove current host from URL\n *\n * @private\n * @param {String} s Absolute or relative URL.\n * @return {String} Root-based relative URL.\n * @author Brendan Byrd\n */\nvar dehostURL = function (s) {\n  var h = location.protocol + \"://\" + location.host;\n  h = h.replace(/([\\.\\\\\\+\\*\\?\\[\\^\\]\\$\\(\\)])/g, '\\\\$1');  // quotemeta\n  return s.replace(new RegExp('^' + h, 'i'), '');\n}\n\n/**\n * Removes all query strings, #IDs, '../' references, and\n * hosts from a URL.\n *\n * @private\n * @param {String} d Base directory.\n * @param {String} s Absolute or relative URL.\n * @return {String} Root-based relative URL.\n * @author Brendan Byrd\n */\nvar cleanURL  = function (d, s) { return dehostURL(toAbsURL(d ? d.split('#')[0].split('?')[0] : defileURL(location.pathname), s ? s.split('#')[0].split('?')[0] : '')); }\n/**\n * Remove filename from URL\n *\n * @private\n * @param {String} s Relative URL.\n * @return {String} Base directory.\n * @author Brendan Byrd\n */\nvar defileURL = function (s)    { return s ? s.substr(0, s.lastIndexOf('/') + 1) : '/'; }\n\n\n// Some extra Array subs for ease of use\n// http://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array\nArray.prototype.hasObject = (\n  !Array.indexOf ? function (obj) {\n    var l = this.length + 1;\n    while (l--) {\n      if (this[l - 1] === obj) return true;\n    }\n    return false;\n  } : function (obj) {\n    return (this.indexOf(obj) !== -1);\n  }\n);\nArray.prototype.hasItemInObj = function (name, item) {\n  var l = this.length + 1;\n  while (l--) {\n    if (this[l - 1][name] === item) return true;\n  }\n  return false;\n};\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (obj, fromIndex) {\n    if (fromIndex == null) {\n      fromIndex = 0;\n    } else if (fromIndex < 0) {\n      fromIndex = Math.max(0, this.length + fromIndex);\n    }\n    for (var i = fromIndex, j = this.length; i < j; i++) {\n      if (this[i] === obj) return i;\n    }\n    return -1;\n  };\n}\nArray.prototype.indexOfObjWithItem = function (name, item, fromIndex) {\n  if (fromIndex == null) {\n    fromIndex = 0;\n  } else if (fromIndex < 0) {\n    fromIndex = Math.max(0, this.length + fromIndex);\n  }\n  for (var i = fromIndex, j = this.length; i < j; i++) {\n    if (this[i][name] === item) return i;\n  }\n  return -1;\n};\n\n/**\n * Borrowed from jquery.base64.js, with some \"Array as input\" corrections\n *\n * @private\n * @param {Array of charCodes} input An array of byte ASCII codes (0-255).\n * @return {String} A base64-encoded string.\n * @author Brendan Byrd\n */\nvar base64Encode = function(input) {\n  var keyString = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  var output = \"\";\n  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n  var i = 0;\n  while (i < input.length) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if      (chr2 == undefined) enc3 = enc4 = 64;\n    else if (chr3 == undefined) enc4 = 64;\n\n    output = output + keyString.charAt(enc1) + keyString.charAt(enc2) + keyString.charAt(enc3) + keyString.charAt(enc4);\n  }\n  return output;\n};\n"},vU3g:function(e,n,o){o("P+fo")(o("n0Zf"))}},[3]);